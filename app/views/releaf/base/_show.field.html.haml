:ruby
  name_without_id_or_type = name.sub(/_(id|type)$/, '')
  field_attributes  = local_assigns.fetch(:field_attributes, {})
  # if view_prefix is not, most likely we came from custom partial.
  # To prevent infinit loop, we set view prefix to something that will prevent
  # us from making infinite loop
  view_prefix = local_assigns.fetch(:view_prefix, 'edit.field_custom_')
  opts = {
    :resource => resource,
    :name => name,
    :view_prefix => view_prefix,
    :field_attributes => field_attributes
  }


- if resource.class.reflect_on_association(name_without_id_or_type).try(:options).try('[]', :polymorphic) == true
  -# name =~ /_id$/ is required to prevent user template from being renedred 2x times:
  -# first time for _id field, second time for _type field
  - if name =~ /_id$/ && has_template?( "_#{view_prefix}.#{name_without_id_or_type}" )
    = render "#{view_prefix}.#{name_without_id_or_type}", opts

- elsif has_template? "_#{view_prefix}.#{name}"
  = render "#{view_prefix}.#{name}", opts

- elsif resource.send(name).blank? == false || resource.errors.has_key?(name.to_sym) || resource.errors.has_key?(name.sub(/_id$/, '').to_sym)
  -# Render fields if they are not blank or have errors
  - render_field_type, use_i18n = render_field_type(resource, name)
  - if use_i18n and has_template?( "_show.field_type_#{render_field_type}_i18n" )
    = render "show.field_type_#{render_field_type}_i18n", opts

  - elsif has_template?( "_show.field_type_#{render_field_type}" )
    = render "show.field_type_#{render_field_type}", opts

  - else
    = render "show.field_type_text", opts
